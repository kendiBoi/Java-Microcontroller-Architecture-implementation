package chinchin;

public class MemoryAccess {
//	This is actually the behaviour of the Memory. So, in order to get to know the address we are willing to access in the memory, we use the result of adding the base address to the offset which is generated by the ALU. The readdata2 (taken as input) is the data we are interested in when we are writing to the memory and this value is the output of the method InstDecode. Finally, we need to set the corresponding signals for memory accessing.

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	public static void MemAccess(String aLUresult, String ReadData2, String immediate2, boolean zeroFlag,
			String branchAddress, boolean memWrite, boolean memRead, boolean branch) {
		System.out.println("");
		System.out.println("Memory Access Stage::");
		System.out.println("");

		
		// TODO Auto-generated method stub
		
		if(memRead==true) {
			Cache.readDataCache(aLUresult);
			System.out.println("addreass of the alu result is: "+aLUresult);
			System.out.println("");
			System.out.println("address in memory is: ");
			
			Memory.Read(aLUresult);
			
			
		}
		else if(memWrite==true) {
			System.out.println("saving in memory with data: "+ ReadData2);
			Cache.writeDataCache(ReadData2);
			System.out.println("saving in memory with data: "+ ReadData2);
			Memory.insertData(ReadData2);
			Memory.Read(ReadData2);
		}
		else if(zeroFlag==true && branch==true){
			setPc(branchAddress,branch,zeroFlag);
		
		}
		else {
			System.out.println("Instruction doesnt access memory");
		}
		
	}
	private static void setPc(String branchAddress, boolean branch, boolean zeroFlag) {
		// TODO Auto-generated method stub
		int pc=0;
		int i=0;

		if(zeroFlag==true && branch==true) {
			while(i<Memory.mem.length) {
				 
				 String[] address = new String[16];
				 String strAddress = new String();
				//	System.out.println(i);
			for(int j=0; j< 16;j++) {
				address[j]=Memory.mem[i][j];
				//System.out.print(address[j] +" ");
				strAddress = strAddress+address[j];
				}
			if(branchAddress.equals(strAddress)) {
				InstructionFetch.ProgCount(pc);	
			}
			pc++;
			i++;
			}
			 
			 if(i==Memory.mem.length) {
				 System.out.println("branch address cannot be found in instruction memory");
			 }
		}
		
	}
	public static void jump(String readData1) {
		// TODO Auto-generated method stub
		System.out.println("Address jump Stage::");
		System.out.println("readData1 is ");
		System.out.println(readData1);
		int pc=0;
		int i=0;
	
			while(i<Memory.ic) {
				 
				 String[] address = new String[16];
				 String strAddress = new String();
				//	System.out.println(i);
			for(int j=0; j< 16;j++) {
				address[j]=Memory.mem[i][j];
				//System.out.print(address[j] +" ");
				strAddress = strAddress+address[j];
				}
			if(readData1.equals(strAddress)) {
				
				InstructionFetch.ProgCount(pc);	
			}
			pc++;
			i++;
			
			System.out.println("");
			}
	}		
	

}
